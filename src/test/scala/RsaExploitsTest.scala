import org.scalatest.GivenWhenThen
import org.scalatest.featurespec.AnyFeatureSpec
import org.scalatest.matchers.should.Matchers.convertToAnyShouldWrapper
import rsa.conversion.{DecodingService, EncodingService}
import rsa.cryptography
import rsa.cryptography.{SignService, VerifyService}
import rsa.key.{KeyPair, KeyPairService, PublicKey}
import rsa.prime.PrimeService

import java.security.SecureRandom

class RsaExploitsTest extends AnyFeatureSpec with GivenWhenThen {

  Feature("rsa") {
    Scenario("sign then verify - product attack") {
      Given("key pair")
      val KeyPair(privateKey, publicKey) = KeyPairService(new PrimeService(new SecureRandom)).generate()

      And("verify / sign services")
      val verifyService = VerifyService(publicKey)
      val signService = SignService(privateKey)

      And("signed message")
      val message_387 = 387
      val _387Signed = signService.sign(message_387)
      verifyService.verify(message_387, _387Signed) shouldBe true

      And("other signed message")
      val message_2 = 2
      val _2Signed = signService.sign(message_2)
      verifyService.verify(message_2, _2Signed) shouldBe true

      Then("prepare signed message without actually signing it")
      val message_774 = 774
      val _774Signed = _387Signed * _2Signed

      And("verify that it is signed")
      verifyService.verify(message_774, _774Signed) shouldBe true
    }

    Scenario("encode / decode - e < n") {
      Given("message")
      val message = "hello"

      And("public key")
      val p = BigInt("10069458730473984409")
      val q = BigInt("9583202228088935837")
      val e = 5
      val publicKey = PublicKey(p*q, e)

      And("encryption service")
      val encryptionService = cryptography.EncryptionService(publicKey)

      And("symbols for encoding")
      lazy val symbols = Array[Char](
        ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
        'u', 'v', 'w', 'x', 'y', 'z'
      )

      And("encoded message")
      val encoded = EncodingService.encode(message, symbols)

      And("encrypted message")
      val encrypted = encryptionService.encrypt(encoded)

      When("math operations to decrypt")
      val decrypted = Math.pow(encrypted.toDouble, 1.0 / publicKey.e.toDouble).toInt

      Then("decoded message should be equal to initial message")
      DecodingService.decode(decrypted, symbols) shouldBe message
    }
  }

}
